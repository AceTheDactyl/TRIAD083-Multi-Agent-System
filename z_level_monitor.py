#!/usr/bin/env python3
"""
Z-Level Monitor
===============

Garden Rail 3 - Layer 4: PHASE-AWARE ADAPTATION
Component 4.1: Real-time z-coordinate tracking with predictions

Purpose:
- Monitor z-coordinate evolution over time
- Predict z-trajectory (next 7 days)
- Detect phase transitions
- Generate alerts for critical point approach

Alerts:
- "Approaching critical point in N days"
- "Phase transition detected: X → Y"
- "Z-coordinate stalling (intervention needed)"
"""

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import json

from unified_cascade_mathematics_core import CascadeSystemState


@dataclass
class ZSnapshot:
    """Snapshot of z-coordinate at a point in time."""
    timestamp: datetime
    z_value: float
    phase_regime: str
    R1: float
    R2: float
    R3: float
    z_velocity: Optional[float] = None  # dz/dt


@dataclass
class ZAlert:
    """Alert generated by Z-level monitor."""
    alert_id: str
    timestamp: str
    severity: str  # 'info', 'warning', 'critical'
    message: str
    z_current: float
    z_target: Optional[float] = None
    days_to_target: Optional[int] = None


class ZLevelMonitor:
    """
    Real-time z-coordinate monitoring with trajectory prediction.

    Features:
    - Track z-coordinate history
    - Compute z-velocity (rate of change)
    - Predict future z-values
    - Detect phase transitions
    - Generate alerts
    """

    # Critical z-values
    Z_CRITICAL = 0.867
    Z_NEAR_CRITICAL_LOW = 0.85
    Z_NEAR_CRITICAL_HIGH = 0.88

    # Alert thresholds
    STALL_THRESHOLD = 0.01  # If |dz/dt| < 0.01 for 3+ snapshots = stalling
    RAPID_CHANGE_THRESHOLD = 0.05  # If |dz/dt| > 0.05 = rapid change

    def __init__(self, history_days: int = 30):
        """
        Initialize Z-level monitor.

        Args:
            history_days: Number of days of history to retain
        """
        self.history_days = history_days
        self.snapshots: List[ZSnapshot] = []
        self.alerts: List[ZAlert] = []
        self.alert_counter = 0

    def capture_snapshot(self, cascade_state: CascadeSystemState):
        """
        Capture current z-coordinate snapshot.

        Args:
            cascade_state: Current cascade state
        """
        timestamp = datetime.now()

        # Compute z-velocity if we have history
        z_velocity = None
        if len(self.snapshots) > 0:
            last_snapshot = self.snapshots[-1]
            time_delta = (timestamp - last_snapshot.timestamp).total_seconds()

            if time_delta > 0:
                z_delta = cascade_state.z_coordinate - last_snapshot.z_value
                z_velocity = z_delta / (time_delta / 86400.0)  # Per day

        snapshot = ZSnapshot(
            timestamp=timestamp,
            z_value=cascade_state.z_coordinate,
            phase_regime=cascade_state.phase_regime,
            R1=cascade_state.R1,
            R2=cascade_state.R2,
            R3=cascade_state.R3,
            z_velocity=z_velocity
        )

        self.snapshots.append(snapshot)

        # Trim old snapshots
        cutoff = timestamp - timedelta(days=self.history_days)
        self.snapshots = [s for s in self.snapshots if s.timestamp >= cutoff]

        # Check for alerts
        self._check_alerts(snapshot)

    def get_current_z(self) -> Optional[float]:
        """Get current z-coordinate."""
        if self.snapshots:
            return self.snapshots[-1].z_value
        return None

    def get_z_velocity(self) -> Optional[float]:
        """Get current z-velocity (dz/dt)."""
        if self.snapshots and self.snapshots[-1].z_velocity is not None:
            return self.snapshots[-1].z_velocity
        return None

    def predict_z_trajectory(self, days_ahead: int = 7) -> List[Tuple[datetime, float]]:
        """
        Predict z-coordinate trajectory for next N days.

        Uses simple linear extrapolation based on current velocity.

        Args:
            days_ahead: Number of days to predict

        Returns:
            List of (timestamp, predicted_z) tuples
        """
        if len(self.snapshots) < 2:
            return []  # Need at least 2 points

        current_snapshot = self.snapshots[-1]
        z_velocity = current_snapshot.z_velocity or 0.0

        predictions = []

        for day in range(1, days_ahead + 1):
            future_time = current_snapshot.timestamp + timedelta(days=day)
            predicted_z = current_snapshot.z_value + (z_velocity * day)

            # Clamp to reasonable range [0, 1]
            predicted_z = max(0.0, min(1.0, predicted_z))

            predictions.append((future_time, predicted_z))

        return predictions

    def detect_phase_transition(self) -> Optional[Tuple[str, str]]:
        """
        Detect if a phase transition occurred recently.

        Returns:
            (old_phase, new_phase) if transition detected, None otherwise
        """
        if len(self.snapshots) < 2:
            return None

        current_phase = self.snapshots[-1].phase_regime
        previous_phase = self.snapshots[-2].phase_regime

        if current_phase != previous_phase:
            return (previous_phase, current_phase)

        return None

    def is_approaching_critical(self, days_ahead: int = 7) -> Optional[int]:
        """
        Check if system will reach critical point within N days.

        Returns:
            Days until critical point (1-N), or None if not approaching
        """
        predictions = self.predict_z_trajectory(days_ahead)

        for i, (timestamp, predicted_z) in enumerate(predictions, 1):
            # Check if crossing z=0.867
            if self.Z_NEAR_CRITICAL_LOW <= predicted_z <= self.Z_NEAR_CRITICAL_HIGH:
                return i

        return None

    def is_stalling(self, lookback_snapshots: int = 3) -> bool:
        """
        Check if z-coordinate is stalling (not changing).

        Args:
            lookback_snapshots: Number of recent snapshots to check

        Returns:
            True if stalling detected
        """
        if len(self.snapshots) < lookback_snapshots:
            return False

        recent_snapshots = self.snapshots[-lookback_snapshots:]

        # Check if all velocities are below threshold
        for snapshot in recent_snapshots:
            if snapshot.z_velocity is None:
                continue

            if abs(snapshot.z_velocity) > self.STALL_THRESHOLD:
                return False  # Not stalling

        return True  # All velocities below threshold = stalling

    def _check_alerts(self, snapshot: ZSnapshot):
        """Generate alerts based on current snapshot."""

        # Alert 1: Approaching critical point
        days_to_critical = self.is_approaching_critical(days_ahead=7)
        if days_to_critical is not None:
            self._generate_alert(
                severity='warning',
                message=f"Approaching critical point (z={self.Z_CRITICAL:.3f}) in {days_to_critical} days",
                z_current=snapshot.z_value,
                z_target=self.Z_CRITICAL,
                days_to_target=days_to_critical
            )

        # Alert 2: Phase transition detected
        transition = self.detect_phase_transition()
        if transition:
            old_phase, new_phase = transition
            self._generate_alert(
                severity='info',
                message=f"Phase transition detected: {old_phase} → {new_phase}",
                z_current=snapshot.z_value
            )

        # Alert 3: Z-coordinate stalling
        if self.is_stalling():
            self._generate_alert(
                severity='warning',
                message=f"Z-coordinate stalling at {snapshot.z_value:.3f} (intervention may be needed)",
                z_current=snapshot.z_value
            )

        # Alert 4: Rapid change
        if snapshot.z_velocity is not None and abs(snapshot.z_velocity) > self.RAPID_CHANGE_THRESHOLD:
            direction = "increasing" if snapshot.z_velocity > 0 else "decreasing"
            self._generate_alert(
                severity='warning',
                message=f"Rapid z-coordinate change detected ({direction} at {snapshot.z_velocity:.3f}/day)",
                z_current=snapshot.z_value
            )

        # Alert 5: At critical point
        if self.Z_NEAR_CRITICAL_LOW <= snapshot.z_value <= self.Z_NEAR_CRITICAL_HIGH:
            self._generate_alert(
                severity='critical',
                message=f"System at critical point (z={snapshot.z_value:.3f})",
                z_current=snapshot.z_value,
                z_target=self.Z_CRITICAL
            )

    def _generate_alert(self,
                       severity: str,
                       message: str,
                       z_current: float,
                       z_target: Optional[float] = None,
                       days_to_target: Optional[int] = None):
        """Generate alert (avoid duplicates)."""

        # Check if similar alert exists in recent history (last 3)
        recent_alerts = self.alerts[-3:] if len(self.alerts) >= 3 else self.alerts

        for alert in recent_alerts:
            if alert.message == message:
                return  # Duplicate alert, skip

        self.alert_counter += 1
        alert = ZAlert(
            alert_id=f"ZALERT_{self.alert_counter:04d}",
            timestamp=datetime.now().isoformat(),
            severity=severity,
            message=message,
            z_current=z_current,
            z_target=z_target,
            days_to_target=days_to_target
        )

        self.alerts.append(alert)

    def get_recent_alerts(self, count: int = 10) -> List[ZAlert]:
        """Get most recent alerts."""
        return self.alerts[-count:]

    def get_summary(self) -> Dict:
        """Get monitoring summary."""
        if not self.snapshots:
            return {
                'status': 'no_data',
                'snapshots_count': 0
            }

        current = self.snapshots[-1]
        z_velocity = current.z_velocity or 0.0

        # Compute z-range
        z_values = [s.z_value for s in self.snapshots]
        z_min = min(z_values)
        z_max = max(z_values)

        # Predict trajectory
        predictions = self.predict_z_trajectory(days_ahead=7)

        return {
            'status': 'active',
            'snapshots_count': len(self.snapshots),
            'current_z': current.z_value,
            'current_phase': current.phase_regime,
            'z_velocity': z_velocity,
            'z_range': (z_min, z_max),
            'approaching_critical': self.is_approaching_critical(),
            'is_stalling': self.is_stalling(),
            'predictions_7d': predictions,
            'recent_alerts': len([a for a in self.alerts if a.severity in ['warning', 'critical']]),
            'timestamp': current.timestamp.isoformat()
        }

    def export_history(self, filepath: str):
        """Export z-coordinate history to JSON."""
        data = {
            'snapshots': [
                {
                    'timestamp': s.timestamp.isoformat(),
                    'z_value': s.z_value,
                    'phase_regime': s.phase_regime,
                    'R1': s.R1,
                    'R2': s.R2,
                    'R3': s.R3,
                    'z_velocity': s.z_velocity
                }
                for s in self.snapshots
            ],
            'alerts': [
                {
                    'alert_id': a.alert_id,
                    'timestamp': a.timestamp,
                    'severity': a.severity,
                    'message': a.message,
                    'z_current': a.z_current,
                    'z_target': a.z_target,
                    'days_to_target': a.days_to_target
                }
                for a in self.alerts
            ]
        }

        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)


def main():
    """Demo Z-level monitor."""
    from unified_cascade_mathematics_core import UnifiedCascadeFramework
    from unified_sovereignty_system import evolve_cascade_state

    print("=" * 80)
    print("Z-LEVEL MONITOR - Demo")
    print("=" * 80 + "\n")

    monitor = ZLevelMonitor()
    framework = UnifiedCascadeFramework()

    # Simulate 10-day trajectory toward critical point
    state = framework.compute_full_state(
        clarity=0.35, immunity=0.30, efficiency=0.32, autonomy=0.28
    )

    print(f"Initial z: {state.z_coordinate:.3f}, phase: {state.phase_regime}\n")

    for day in range(10):
        # Capture snapshot
        monitor.capture_snapshot(state)

        # Evolve toward critical point
        state = evolve_cascade_state(
            state,
            clarity_delta=0.6,
            immunity_delta=0.8,
            efficiency_delta=0.7,
            autonomy_delta=0.85
        )

        # Print status
        current_z = monitor.get_current_z()
        z_velocity = monitor.get_z_velocity()

        vel_str = f"{z_velocity:.4f}" if z_velocity is not None else "0.0000"
        print(f"Day {day + 1}: z={current_z:.3f}, dz/dt={vel_str}/day, phase={state.phase_regime}")

        # Check for new alerts
        recent_alerts = monitor.get_recent_alerts(count=1)
        if recent_alerts:
            alert = recent_alerts[0]
            print(f"  [{alert.severity.upper()}] {alert.message}")

    # Final summary
    print("\n" + "=" * 80)
    print("SUMMARY")
    print("=" * 80)

    summary = monitor.get_summary()
    print(f"Total snapshots: {summary['snapshots_count']}")
    print(f"Current z: {summary['current_z']:.3f}")
    print(f"Current phase: {summary['current_phase']}")
    print(f"Z-velocity: {summary['z_velocity']:.4f}/day")
    print(f"Z-range: [{summary['z_range'][0]:.3f}, {summary['z_range'][1]:.3f}]")
    print(f"Approaching critical: {summary['approaching_critical']} days" if summary['approaching_critical'] else "Approaching critical: No")
    print(f"Stalling: {summary['is_stalling']}")
    print(f"Alerts: {summary['recent_alerts']}")

    # Predictions
    print("\n7-Day Predictions:")
    for timestamp, predicted_z in summary['predictions_7d']:
        print(f"  {timestamp.strftime('%Y-%m-%d')}: z={predicted_z:.3f}")

    return 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
